

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>rm_classifier.umap_classifier &mdash; rm_classifier 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >

          
          
          <a href="../../index.html" class="icon icon-home">
            rm_classifier
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/rm_classifier.html">rm_classifier package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/rm_classifier.helpers.html">rm_classifier.helpers package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorials</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">rm_classifier</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">rm_classifier.umap_classifier</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for rm_classifier.umap_classifier</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">UMAP Classifier with DBSCAN for Radio Monitoring with DBSCAN</span>
<span class="sd">============================================================</span>
<span class="sd">Author: Johann Luca Kastner</span>
<span class="sd">Date: 15/09/2025</span>
<span class="sd">License: MIT License</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="n">script_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">script_dir</span><span class="p">))</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">rm_classifier.prepare_data</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">prepare_data</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">rm_classifier.helpers</span><span class="w"> </span><span class="kn">import</span> <span class="n">statistical_models</span><span class="p">,</span> <span class="n">visualization</span><span class="p">,</span> <span class="n">umap_data_loader</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">umap.umap_</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">umap</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">DBSCAN</span><span class="p">,</span> <span class="n">HDBSCAN</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.neighbors</span><span class="w"> </span><span class="kn">import</span> <span class="n">NearestNeighbors</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.distance</span><span class="w"> </span><span class="kn">import</span> <span class="n">cdist</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">joblib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<div class="viewcode-block" id="UMAPClassifier">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UMAPClassifier</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to handle UMAP classification tasks especially for radio monitoring data.</span>
<span class="sd">    This class provides methods for data preparation, UMAP embedding, clustering with DBSCAN,</span>
<span class="sd">    and various prediction methods based on cluster statistics.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        yaml_path (str, optional): Path to the YAML configuration file. Defaults to None, which means no YAML file is loaded.</span>
<span class="sd">        model_name (str, optional): Name of the model. Defaults to &quot;umap_classifier&quot;.</span>
<span class="sd">        dir (str, optional): Directory to save the model. Defaults to &quot;umap_classifier&quot;.</span>
<span class="sd">        n_neighbors (int, optional): Number of neighbors for UMAP. Defaults to 35.</span>
<span class="sd">        min_dist (float, optional): Minimum distance between points in UMAP. Defaults to 0.0.</span>
<span class="sd">        n_components (int, optional): Number of dimensions in the latent space. Defaults to 2.</span>
<span class="sd">        metric (str, optional): Distance metric for UMAP. Defaults to &quot;braycurtis&quot;.</span>
<span class="sd">        input_data_type (str, optional): Type of input data (e.g., &quot;fft&quot;, &quot;time&quot;, &quot;fft_time&quot;, &quot;fft_phase&quot;). Defaults to &quot;time&quot;.</span>
<span class="sd">        data_preparation (dict, optional): Dictionary containing data preparation parameters.</span>
<span class="sd">            These override the default parameters. The following keys are supported:</span>

<span class="sd">            - **spectrum_filter** (str, optional): Type of filter to apply to the spectrum.</span>
<span class="sd">            - **denoiser_n** (int): Number of denoiser iterations.</span>
<span class="sd">            - **denoiser_npeak** (int): Number of peaks for the denoiser.</span>
<span class="sd">            - **welch_nperseg** (int): Length of each segment for Welch&#39;s method.</span>
<span class="sd">            - **welch_noverlap** (int): Number of points to overlap between segments.</span>
<span class="sd">            - **welch_window** (str): Type of window to use in Welch&#39;s method.</span>
<span class="sd">            - **welch_average** (str): Averaging method for Welch&#39;s method (e.g., &quot;mean&quot; or &quot;median&quot;).</span>
<span class="sd">            - **windowing** (str): Type of windowing function to apply.</span>
<span class="sd">            - **log_filter** (bool): Whether to apply a logarithmic filter.</span>
<span class="sd">            - **cut_beacon_frequencies** (bool): Whether to cut beacon frequencies.</span>
<span class="sd">            - **beacon_frequencies** (list): Frequencies of the beacons.</span>
<span class="sd">            - **beacon_width** (float): Width of the beacons.</span>

<span class="sd">            Defaults to an empty dictionary.</span>
<span class="sd">        db_eps (float, optional): The maximum distance between two samples for one to be considered as in the neighborhood of the other in DBSCAN. Defaults to 0.45.</span>
<span class="sd">        db_min_samples (int, optional): The number of samples in a neighborhood for a point to be considered as a core point in DBSCAN. Defaults to 50.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="UMAPClassifier.__init__">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">yaml_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;umap_classifier&quot;</span><span class="p">,</span>
                 <span class="nb">dir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;umap_classifier&quot;</span><span class="p">,</span>
                 <span class="n">n_neighbors</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">35</span><span class="p">,</span>
                 <span class="n">min_dist</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
                 <span class="n">n_components</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                 <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;braycurtis&quot;</span><span class="p">,</span>
                 <span class="n">input_data_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span>
                 <span class="n">data_preparation</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span>
                 <span class="n">db_eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.45</span><span class="p">,</span>
                 <span class="n">db_min_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
                 <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yaml_path</span> <span class="o">=</span> <span class="n">yaml_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span> <span class="o">=</span> <span class="n">model_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dir</span> <span class="o">=</span> <span class="nb">dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_dist</span> <span class="o">=</span> <span class="n">min_dist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">=</span> <span class="n">n_components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_data_type</span> <span class="o">=</span> <span class="n">input_data_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_preparation</span> <span class="o">=</span> <span class="n">data_preparation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db_eps</span> <span class="o">=</span> <span class="n">db_eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db_min_samples</span> <span class="o">=</span> <span class="n">db_min_samples</span>
        <span class="k">if</span> <span class="n">yaml_path</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_yaml</span><span class="p">(</span><span class="n">yaml_path</span><span class="p">)</span>
        <span class="n">default_data_preparation_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;target_data_type&quot;</span><span class="p">:</span> <span class="s2">&quot;fft&quot;</span><span class="p">,</span>
            <span class="s2">&quot;suppress_dc&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;spectrum_filter&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="c1"># None, welch, denoiser</span>
            <span class="s2">&quot;windowing&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="c1"># None, hamming, hanning, blackman, blackmanharris, bartlett, kaiser</span>
            <span class="s2">&quot;log_filter&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;cut_beacon_frequencies&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;normalization&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="c1"># standard zscore normalization</span>
            <span class="s2">&quot;avg_pooling&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="c1"># int of an precedent avg_pooling layer,</span>
            <span class="s2">&quot;max_pooling&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="c1"># int of an precedent max_pooling layer,</span>
            <span class="s2">&quot;denoiser_n&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
            <span class="s2">&quot;denoiser_npeak&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
            <span class="s2">&quot;welch_nperseg&quot;</span><span class="p">:</span> <span class="mi">512</span><span class="p">,</span>
            <span class="s2">&quot;welch_noverlap&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;welch_window&quot;</span><span class="p">:</span> <span class="s1">&#39;boxcar&#39;</span><span class="p">,</span>
            <span class="s2">&quot;welch_average&quot;</span><span class="p">:</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span>
            <span class="s2">&quot;beacon_frequencies&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;beacon_width&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;frequency_bins&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;sampling_frequency&quot;</span><span class="p">:</span> <span class="mi">180</span><span class="p">,</span>  <span class="c1"># Default sampling frequency in MHz</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_preparation</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">default_data_preparation_dict</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">data_preparation</span><span class="p">}</span></div>

            
    <span class="k">def</span><span class="w"> </span><span class="nf">_load_yaml</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yaml_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load parameters from a YAML file.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            yaml_path (str): Path to the YAML file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">yaml</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">yaml_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    
<div class="viewcode-block" id="UMAPClassifier.prepare_data">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.prepare_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prepare_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">data_preparation</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare data for UMAP classification.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): Input data to be prepared.</span>
<span class="sd">            verbose (bool, optional): Whether to print preparation details. Defaults to True.</span>
<span class="sd">            data_preparation (dict, optional): Dictionary containing data preparation parameters to override the class defaults</span>
<span class="sd">                Defaults to an empty dictionary.</span>
<span class="sd">            **kwargs: Additional keyword arguments to override class attributes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Prepared data ready for UMAP classification.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reset_normalization</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_preparation</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_preparation</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Overriding </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> in data_preparation dict with value </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> from kwargs.&quot;</span><span class="p">)</span>
                    <span class="n">reset_normalization</span><span class="o">=</span><span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data_preparation</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                
            <span class="k">elif</span> <span class="n">key</span> <span class="o">!=</span> <span class="s2">&quot;data_preparation&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding new key </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> with value </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> to the class instance.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data_preparation</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_preparation</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Overriding </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> with value </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> from data_preparation dict.&quot;</span><span class="p">)</span>
                <span class="n">reset_normalization</span><span class="o">=</span><span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_preparation</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            
        <span class="k">if</span> <span class="n">reset_normalization</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_preparation</span><span class="p">[</span><span class="s2">&quot;rd_train_mean&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_preparation</span><span class="p">[</span><span class="s2">&quot;rd_train_std&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Resetting normalization parameters due to changes in data preparation.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preparing data with parameters: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data_preparation</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">prepared_data</span> <span class="o">=</span> <span class="n">prepare_data</span><span class="o">.</span><span class="n">prepare_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">data</span>
        <span class="n">prepared_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_preparation</span> <span class="o">=</span> <span class="n">prepare_data</span><span class="o">.</span><span class="n">normalize_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prepared_data</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="n">prepared_data</span> <span class="o">=</span> <span class="n">prepare_data</span><span class="o">.</span><span class="n">pooling_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prepared_data</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">prepared_data</span></div>

    
<div class="viewcode-block" id="UMAPClassifier.custom_prepare_data">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.custom_prepare_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">custom_prepare_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">custom_prepare_fcn</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare data using a custom preparation function.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): Input data to be prepared.</span>
<span class="sd">            custom_prepare_fcn (callable): Custom function to prepare the data. It should accept</span>
<span class="sd">                the data as its first argument and return the prepared data.</span>
<span class="sd">            verbose (bool, optional): Whether to print preparation details. Defaults to True.</span>
<span class="sd">            **kwargs: Additional keyword arguments to pass to the custom preparation function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Prepared data.  </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">custom_prepare_fcn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;custom_prepare_fcn must be provided.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preparing data with custom function: </span><span class="si">{</span><span class="n">custom_prepare_fcn</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_preparation</span><span class="p">[</span><span class="s2">&quot;custom_prepare_fcn&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">custom_prepare_fcn</span>
        <span class="k">return</span> <span class="n">custom_prepare_fcn</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="UMAPClassifier.train_embed">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.train_embed">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">train_embed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">keep_model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_model</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">umap_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Train the UMAP model and embed the training data into a lower-dimensional space using UMAP.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): Input data to be embedded.</span>
<span class="sd">            keep_model (bool, optional): Whether to save the trained UMAP model as the class variable self.umap_model. Defaults to True.</span>
<span class="sd">            save_model (str, optional): Path to save the trained UMAP model using joblib. Defaults to None, which means the model is not saved to disk.</span>
<span class="sd">            verbose (bool, optional): Whether to print embedding details. Defaults to True.</span>
<span class="sd">            umap_kwargs (dict, optional): Additional keyword arguments to pass to the UMAP constructor. Defaults to empty dict.</span>
<span class="sd">            **kwargs: Additional keyword arguments to override class attributes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Embedded data in lower-dimensional space.</span>
<span class="sd">            &quot;&quot;&quot;</span>
        
        <span class="n">all_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">umap_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}}</span>
        <span class="n">new_all_kwargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">all_kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">new_all_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Overriding </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> with value </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> from kwargs.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="s1">&#39;min_dist&#39;</span><span class="p">,</span> <span class="s1">&#39;n_components&#39;</span><span class="p">,</span> <span class="s1">&#39;metric&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removing </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> from kwargs.&quot;</span><span class="p">)</span>
                <span class="n">all_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Embedding data with parameters: n_neighbors=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="si">}</span><span class="s2">, min_dist=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">min_dist</span><span class="si">}</span><span class="s2">, n_components=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="si">}</span><span class="s2">, metric=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">umap_model</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span>
            <span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
            <span class="n">min_dist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_dist</span><span class="p">,</span> 
            <span class="n">n_components</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> 
            <span class="n">metric</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span> 
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="o">**</span><span class="n">all_kwargs</span>
            <span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">embedding</span> <span class="o">=</span> <span class="n">umap_model</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_model</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saving UMAP model to </span><span class="si">{</span><span class="n">save_model</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_model</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">umap_model</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep_model</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">umap_model</span> <span class="o">=</span> <span class="n">umap_model</span>
        <span class="k">return</span> <span class="n">embedding</span></div>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_set_cluster_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">labels</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Exclude noise points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_indices</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_dbscan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">keep_model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_model</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">db_model</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">db_eps</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">db_min_samples</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_model</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saving DBSCAN model to </span><span class="si">{</span><span class="n">save_model</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_model</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">db_model</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep_model</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">db_model</span> <span class="o">=</span> <span class="n">db_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_cluster_indices</span><span class="p">(</span><span class="n">db_model</span><span class="o">.</span><span class="n">labels_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">db_model</span><span class="o">.</span><span class="n">labels_</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_hdbscan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">keep_model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_model</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hdb_kwargs</span><span class="p">):</span>
        <span class="n">hdb_model</span> <span class="o">=</span> <span class="n">HDBSCAN</span><span class="p">(</span><span class="o">**</span><span class="n">hdb_kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_model</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saving HDBSCAN model to </span><span class="si">{</span><span class="n">save_model</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_model</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">hdb_model</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep_model</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hdb_model</span> <span class="o">=</span> <span class="n">hdb_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_cluster_indices</span><span class="p">(</span><span class="n">hdb_model</span><span class="o">.</span><span class="n">labels_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hdb_model</span><span class="o">.</span><span class="n">labels_</span>
    
<div class="viewcode-block" id="UMAPClassifier.db_classify">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.db_classify">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">db_classify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">keep_model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_model</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">auto_eps</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classify data using DBSCAN clustering.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): Input data to be classified.</span>
<span class="sd">            keep_model (bool, optional): Whether to save the trained DBSCAN model as the class variable self.db_model. Defaults to True.</span>
<span class="sd">            save_model (str, optional): Path to save the trained DBSCAN model using joblib. Defaults to None, which means the model is not saved to disk.</span>
<span class="sd">            auto_eps (bool, optional): Whether to automatically determine optimal DBSCAN parameters. Defaults to False.</span>
<span class="sd">            verbose (bool, optional): Whether to print classification details. Defaults to True.</span>
<span class="sd">            **kwargs: Additional keyword arguments to override class attributes.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Cluster labels for each data point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Overriding </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> with value </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> from kwargs.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">auto_eps</span><span class="p">:</span>
            <span class="n">k</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_min_samples</span><span class="p">)</span>
            <span class="n">nbrs</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
            <span class="n">nbrs</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">sorted_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">distances</span><span class="p">[:,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">db_eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">sorted_data</span><span class="p">,</span> <span class="mf">0.98</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Automatically determined db_eps: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">db_eps</span><span class="si">}</span><span class="s2"> using the .98th percentile of the </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">-distance.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dbscan</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">keep_model</span><span class="o">=</span><span class="n">keep_model</span><span class="p">,</span> <span class="n">save_model</span><span class="o">=</span><span class="n">save_model</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="UMAPClassifier.k_distance_plot">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.k_distance_plot">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">k_distance_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a k-distance plot to help determine the optimal epsilon value for DBSCAN.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): Input data for which to generate the k-distance plot.</span>
<span class="sd">            k (int, optional): The number of nearest neighbors to consider. Defaults to 50.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None: Displays the k-distance plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nbrs</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
        <span class="n">nbrs</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">sorted_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">distances</span><span class="p">[:,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_data</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">visualization</span><span class="o">.</span><span class="n">plot_k_distance</span><span class="p">(</span><span class="n">sorted_data</span><span class="p">,</span> <span class="n">cdf</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span></div>

    
        
<div class="viewcode-block" id="UMAPClassifier.hdb_classify">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.hdb_classify">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">hdb_classify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">keep_model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_model</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">hdb_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classify data using HDBSCAN clustering.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): Input data to be classified.</span>
<span class="sd">            keep_model (bool, optional): Whether to save the trained HDBSCAN model as the class variable self.hdb_model. Defaults to True.</span>
<span class="sd">            save_model (str, optional): Path to save the trained HDBSCAN model using joblib. Defaults to None, which means the model is not saved to disk.</span>
<span class="sd">            verbose (bool, optional): Whether to print classification details. Defaults to True.</span>
<span class="sd">            hdb_kwargs (dict, optional): Additional keyword arguments to pass to the HDBSCAN constructor. Defaults to empty dict.</span>
<span class="sd">            **kwargs: Additional keyword arguments to override class attributes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Cluster labels for each data point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Overriding </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> with value </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> from kwargs.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdb_kwargs</span> <span class="o">=</span> <span class="n">hdb_kwargs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hdbscan</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">keep_model</span><span class="o">=</span><span class="n">keep_model</span><span class="p">,</span> <span class="n">save_model</span><span class="o">=</span><span class="n">save_model</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    

    <span class="c1">### Cluster trace methods</span>
<div class="viewcode-block" id="UMAPClassifier.save_cluster_trace">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.save_cluster_trace">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_cluster_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">trace_statistic</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save cluster as class variables traces based on the provided statistic.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): The input data from which to calculate cluster traces.</span>
<span class="sd">            clusters (np.ndarray): Array of cluster indices for each data point.</span>
<span class="sd">            trace_statistic (str, optional): Statistic to use for calculating cluster traces. </span>
<span class="sd">                Options are &quot;mean&quot;, &quot;median&quot;, &quot;min&quot;, &quot;max&quot;, &quot;std&quot;, or &quot;quantile&quot;. Defaults to &quot;mean&quot;.</span>
<span class="sd">            verbose (bool, optional): Whether to print progress messages. Defaults to True.</span>
<span class="sd">            modifier_function_name (str, optional): Name of the modifier function applied to the data before calculating traces.</span>
<span class="sd">                This is used to differentiate between traces calculated on raw and modified data. Defaults to an empty string.</span>
<span class="sd">            q (float, optional): Quantile value to use if trace_statistic is &quot;quantile&quot;. Must be between 0 and 1. Defaults to 0.1.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_set_cluster_indices</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_indices</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Provided clusters do not match the model&#39;s cluster indices. Setting them to the model&#39;s cluster indices.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_cluster_indices</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length of cluster indices must match length of data.&quot;</span><span class="p">)</span>
        <span class="n">cluster_traces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cluster_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">trace_statistic</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
                <span class="n">cluster_trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">clusters</span> <span class="o">==</span> <span class="n">cluster_idx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">trace_statistic</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
                <span class="n">cluster_trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">clusters</span> <span class="o">==</span> <span class="n">cluster_idx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">trace_statistic</span> <span class="o">==</span> <span class="s2">&quot;std&quot;</span><span class="p">:</span>
                <span class="n">cluster_trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">clusters</span> <span class="o">==</span> <span class="n">cluster_idx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">trace_statistic</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
                <span class="n">cluster_trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">clusters</span> <span class="o">==</span> <span class="n">cluster_idx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">trace_statistic</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
                <span class="n">cluster_trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">clusters</span> <span class="o">==</span> <span class="n">cluster_idx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">trace_statistic</span> <span class="o">==</span> <span class="s2">&quot;quantile&quot;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">cluster_trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">clusters</span> <span class="o">==</span> <span class="n">cluster_idx</span><span class="p">],</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;trace_statistic must start with &#39;quantile_&#39; and followed by a float value.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid cluster_statistic. Choose from &#39;mean&#39;, &#39;median&#39;, &#39;min&#39;, &#39;max&#39;, &#39;std&#39; or &#39;quantile&#39;.&quot;</span><span class="p">)</span>
            <span class="n">cluster_traces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster_trace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">trace_statistic</span> <span class="o">==</span> <span class="s2">&quot;quantile&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">quantile_traces&#39;</span><span class="p">):</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">quantile_traces&#39;</span><span class="p">)[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cluster_traces</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">quantile_traces&#39;</span><span class="p">,</span> <span class="p">{</span><span class="n">q</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cluster_traces</span><span class="p">)})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}{</span><span class="n">trace_statistic</span><span class="si">}</span><span class="s1">_traces&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cluster_traces</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_traces</span><span class="p">)</span><span class="si">}</span><span class="s2"> cluster traces with </span><span class="si">{</span><span class="n">trace_statistic</span><span class="si">}</span><span class="s2"> statistic.&quot;</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">cluster_traces</span></div>


<div class="viewcode-block" id="UMAPClassifier.get_cluster_trace">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.get_cluster_trace">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_cluster_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_idx</span><span class="p">,</span> <span class="n">trace_statistic</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the trace for a specific cluster based on the provided statistic.</span>

<span class="sd">        Args:   </span>
<span class="sd">            cluster_idx (int): The index of the cluster for which to retrieve the trace.</span>
<span class="sd">            trace_statistic (str, optional): Statistic used for calculating the cluster trace.</span>
<span class="sd">                Options are &quot;mean&quot;, &quot;median&quot;, &quot;min&quot;, &quot;max&quot;, &quot;std&quot;, or &quot;quantile&quot;. Defaults to &quot;mean&quot;.</span>
<span class="sd">            modifier_function_name (str, optional): Name of the modifier function applied to the data before calculating traces.</span>
<span class="sd">                This is used to differentiate between traces calculated on raw and modified data. Defaults to an empty string.</span>
<span class="sd">            q (float, optional): Quantile value to use if trace_statistic is &quot;quantile&quot;. Must be between 0 and 1. Defaults to 0.5.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The trace of the specified cluster.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">trace_statistic</span> <span class="o">==</span> <span class="s2">&quot;quantile&quot;</span><span class="p">:</span>
            <span class="n">quantile_traces</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">quantile_traces&#39;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="k">return</span> <span class="n">quantile_traces</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="kc">None</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_indices</span> <span class="o">==</span> <span class="n">cluster_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}{</span><span class="n">trace_statistic</span><span class="si">}</span><span class="s1">_traces&#39;</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_indices</span> <span class="o">==</span> <span class="n">cluster_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>

    
<div class="viewcode-block" id="UMAPClassifier.save_modified_cluster_trace">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.save_modified_cluster_trace">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_modified_cluster_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">modifier_function</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trace_statistic</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a modifier function to the data and save the cluster traces based on the provided statistic.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): The input data from which to calculate cluster traces.</span>
<span class="sd">            clusters (np.ndarray): Array of cluster indices for each data point.</span>
<span class="sd">            modifier_function (callable): Function to modify the data before calculating traces.</span>
<span class="sd">            modifier_function_name (str, optional): Name of the modifier function. If None, the function&#39;s __name__ attribute is used.</span>
<span class="sd">            trace_statistic (str, optional): Statistic to use for calculating cluster traces.</span>
<span class="sd">                Options are &quot;mean&quot;, &quot;median&quot;, &quot;min&quot;, &quot;max&quot;, &quot;std&quot;, or &quot;quantile&quot;. Defaults to &quot;mean&quot;.</span>
<span class="sd">            verbose (bool, optional): Whether to print progress messages. Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">modifier_function_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">modifier_function_name</span> <span class="o">=</span> <span class="n">modifier_function</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">modifier_function</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>       
        <span class="bp">self</span><span class="o">.</span><span class="n">save_cluster_trace</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">trace_statistic</span><span class="o">=</span><span class="n">trace_statistic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="n">modifier_function_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="UMAPClassifier.save_cluster_cholesky_factors">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.save_cluster_cholesky_factors">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_cluster_cholesky_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save cluster Cholesky factors as class variables.       </span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): The input data from which to calculate cluster Cholesky factors.</span>
<span class="sd">            clusters (np.ndarray): Array of cluster indices for each data point.</span>
<span class="sd">            eps (float, optional): Small value added to the diagonal of the covariance matrix for numerical stability. Defaults to 1e-8.</span>
<span class="sd">            verbose (bool, optional): Whether to print progress messages. Defaults to True.</span>
<span class="sd">            modifier_function_name (str, optional): Name of the modifier function applied to the data before calculating Cholesky factors.</span>
<span class="sd">                This is used to differentiate between factors calculated on raw and modified data. Defaults to an empty string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">datatype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_set_cluster_indices</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_indices</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Provided clusters do not match the model&#39;s cluster indices. Setting them to the model&#39;s cluster indices.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_cluster_indices</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length of cluster indices must match length of data.&quot;</span><span class="p">)</span>
        <span class="n">cluster_W_matrices</span><span class="p">,</span> <span class="n">cluster_log_dets</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cluster_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_indices</span><span class="p">:</span>
            <span class="n">cov_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">clusters</span> <span class="o">==</span> <span class="n">cluster_idx</span><span class="p">],</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">W</span><span class="p">,</span> <span class="n">log_det</span> <span class="o">=</span> <span class="n">statistical_models</span><span class="o">.</span><span class="n">cholesky_factors</span><span class="p">(</span><span class="n">cov_matrix</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">datatype</span><span class="p">),</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
            <span class="n">cluster_W_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
            <span class="n">cluster_log_dets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">log_det</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">W_matrices_traces&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cluster_W_matrices</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">log_dets_traces&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cluster_log_dets</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_W_matrices</span><span class="p">)</span><span class="si">}</span><span class="s2"> cluster Cholesky factors.&quot;</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">cluster_W_matrices</span><span class="p">,</span> <span class="n">cluster_log_dets</span></div>


<div class="viewcode-block" id="UMAPClassifier.save_modified_cluster_cholesky_factors">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.save_modified_cluster_cholesky_factors">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_modified_cluster_cholesky_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">modifier_function</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a modifier function to the data and save the cluster Cholesky factors.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): The input data from which to calculate cluster Cholesky factors.</span>
<span class="sd">            clusters (np.ndarray): Array of cluster indices for each data point.</span>
<span class="sd">            modifier_function (callable): Function to modify the data before calculating Cholesky factors.</span>
<span class="sd">            modifier_function_name (str, optional): Name of the modifier function. If None, the function&#39;s __name__ attribute is used.</span>
<span class="sd">            eps (float, optional): Small value added to the diagonal of the covariance matrix for numerical stability. Defaults to 1e-8.</span>
<span class="sd">            verbose (bool, optional): Whether to print progress messages. Defaults to True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">modifier_function_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">modifier_function_name</span> <span class="o">=</span> <span class="n">modifier_function</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">modifier_function</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">save_cluster_cholesky_factors</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="n">modifier_function_name</span><span class="p">)</span></div>


    <span class="c1">### Prediction methods</span>
<div class="viewcode-block" id="UMAPClassifier.prepare_minimum_distance_prediction">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.prepare_minimum_distance_prediction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prepare_minimum_distance_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">trace_statistic</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare for minimum distance prediction by calculating and saving the median distances of each cluster trace.</span>
<span class="sd">        And also ensures that the cluster traces are calculated and saved.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): The input data to be classified.</span>
<span class="sd">            clusters (np.ndarray): Array of cluster indices for each data point.</span>
<span class="sd">            metric (str, optional): Distance metric to use. Defaults to &#39;euclidean&#39;.</span>
<span class="sd">            trace_statistic (str, optional): Statistic used for calculating the cluster traces. Options are &quot;mean&quot;, &quot;median&quot;, &quot;min&quot;, &quot;max&quot;, &quot;std&quot;, or &quot;quantile&quot;. Defaults to &quot;mean&quot;.</span>
<span class="sd">            modifier_function_name (str, optional): Name of the modifier function applied to the data before calculating traces. This is used to differentiate between traces calculated on raw and modified data. Defaults to an empty string.</span>
<span class="sd">            verbose (bool, optional): Whether to print progress messages. Defaults to True.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">                &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_cluster_trace</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">trace_statistic</span><span class="o">=</span><span class="n">trace_statistic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="n">modifier_function_name</span><span class="p">)</span>
        <span class="n">compared_traces</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}{</span><span class="n">trace_statistic</span><span class="si">}</span><span class="s1">_traces&#39;</span><span class="p">)</span>
        <span class="n">median_cluster_distance</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cluster_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_indices</span><span class="p">:</span>
            <span class="n">cluster_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">clusters</span> <span class="o">==</span> <span class="n">cluster_idx</span><span class="p">]</span>
            <span class="n">median_cluster_distance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">cdist</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">,</span> <span class="p">[</span><span class="n">compared_traces</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]],</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)))</span>
        <span class="n">median_cluster_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">median_cluster_distance</span><span class="p">)</span><span class="o">/</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Normalize by number of features</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}{</span><span class="n">trace_statistic</span><span class="si">}</span><span class="s1">_median_distances_</span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">median_cluster_distance</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="UMAPClassifier.minimum_distance_prediction">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.minimum_distance_prediction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">minimum_distance_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">max_distance</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">noise_alpha</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">trace_statistic</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict cluster labels based on the minimum distance to cluster traces.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): The input data to be classified.</span>
<span class="sd">            metric (str, optional): Distance metric to use. Defaults to &quot;euclidean&quot;.</span>
<span class="sd">            noise_alpha (float, optional): Multiplier for the median distance to determine noise threshold. Points with a distance greater than median_distance * noise_alpha are labeled as noise (-1). Defaults to 100.</span>
<span class="sd">            max_distance (float, optional): Maximum distance to consider a point as belonging to a cluster. Points with a distance greater than max_distance are labeled as noise (-1). Defaults to 1.0.</span>
<span class="sd">            trace_statistic (str, optional): Statistic used for calculating the cluster traces. Options are &quot;mean&quot;, &quot;median&quot;, &quot;min&quot;, &quot;max&quot;, &quot;std&quot;, or &quot;quantile&quot;. Defaults to &quot;mean&quot;.</span>
<span class="sd">            modifier_function_name (str, optional): Name of the modifier function applied to the data before calculating traces. This is used to differentiate between traces calculated on raw and modified data. Defaults to an empty string.</span>
<span class="sd">            verbose (bool, optional): Whether to print progress messages. Defaults to True.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            predicted_cluster (np.ndarray): Predicted cluster labels for each data point.</span>
<span class="sd">            minimum_distances (np.ndarray): Minimum distances to the nearest cluster trace for each data point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}{</span><span class="n">trace_statistic</span><span class="si">}</span><span class="s1">_traces&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster traces with statistic &#39;</span><span class="si">{</span><span class="n">trace_statistic</span><span class="si">}</span><span class="s2">&#39; and modifier function &#39;</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s2">&#39; not found. Please run &#39;save_cluster_trace&#39; or &#39;save_modified_cluster_trace&#39; first.&quot;</span><span class="p">)</span>
        
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cdist</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}{</span><span class="n">trace_statistic</span><span class="si">}</span><span class="s1">_traces&#39;</span><span class="p">),</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">))</span><span class="o">/</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Normalize by number of features</span>
        <span class="n">predicted_cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_indices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">minimum_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">predicted_cluster</span><span class="p">[</span><span class="n">minimum_distances</span> <span class="o">&gt;</span> <span class="n">max_distance</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Mark as noise if distance exceeds max_distance</span>
        <span class="n">predicted_cluster</span><span class="p">[</span><span class="n">minimum_distances</span> <span class="o">&gt;</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}{</span><span class="n">trace_statistic</span><span class="si">}</span><span class="s1">_median_distances_</span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)[</span><span class="n">predicted_cluster</span><span class="p">]</span> <span class="o">*</span> <span class="n">noise_alpha</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Mark as noise if distance exceeds median distance * noise_alpha</span>
        <span class="k">return</span> <span class="n">predicted_cluster</span><span class="p">,</span> <span class="n">minimum_distances</span></div>

    
<div class="viewcode-block" id="UMAPClassifier.prepare_ml_uncorrelated_normal_prediction">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.prepare_ml_uncorrelated_normal_prediction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prepare_ml_uncorrelated_normal_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare for maximum likelihood prediction assuming uncorrelated normal distributions by calculating and saving the median uncorrelated normal likelihoods of each cluster.</span>
<span class="sd">        And also ensures that the cluster mean and std traces are calculated and saved.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): The input data to be classified.</span>
<span class="sd">            clusters (np.ndarray): Array of cluster indices for each data point.</span>
<span class="sd">            modifier_function_name (str, optional): Name of the modifier function applied to the data before calculating traces. This is used to differentiate between traces calculated on raw and modified data. Defaults to an empty string.</span>
<span class="sd">            verbose (bool, optional): Whether to print progress messages. Defaults to True.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">datatype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_cluster_trace</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">trace_statistic</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="n">modifier_function_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_cluster_trace</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">trace_statistic</span><span class="o">=</span><span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="n">modifier_function_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating median uncorrelated normal likelihoods for each cluster.&quot;</span><span class="p">)</span> 
        <span class="n">median_logls</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">bin_means</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">mean_traces&#39;</span><span class="p">)</span>
        <span class="n">bin_stds</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">std_traces&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cluster_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_indices</span><span class="p">:</span>
            
            <span class="n">cluster_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">clusters</span> <span class="o">==</span> <span class="n">cluster_idx</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">median_logls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">statistical_models</span><span class="o">.</span><span class="n">logl_uncorrelated_normal</span><span class="p">(</span><span class="n">cluster_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">datatype</span><span class="p">),</span> 
                                                                                      <span class="n">bin_means</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">:</span><span class="n">cluster_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">datatype</span><span class="p">),</span> 
                                                                                      <span class="n">bin_stds</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">:</span><span class="n">cluster_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">datatype</span><span class="p">))))</span>
        <span class="n">median_logls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">median_logls</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">_median_uncorrelated_normal_likelihood&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">median_logls</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">None</span>     </div>


<div class="viewcode-block" id="UMAPClassifier.ml_uncorrelated_normal_prediction">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.ml_uncorrelated_normal_prediction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ml_uncorrelated_normal_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">noise_alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_logl</span><span class="o">=-</span><span class="mi">100</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                                            <span class="n">data_batch_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">cluster_batch_size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict cluster labels based on maximum likelihood estimation assuming uncorrelated normal distributions.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): The input data to be classified.</span>
<span class="sd">            noise_alpha (float, optional): Multiplier for the median likelihood to determine noise threshold. Points with a likelihood below median_likelihood * noise_alpha are labeled as noise (-1). Defaults to 0.</span>
<span class="sd">            min_logl (float, optional): Minimum log-likelihood threshold to consider a point as belonging to a cluster. Points with a log-likelihood below min_logl are labeled as noise (-1). Defaults to -100.</span>
<span class="sd">            modifier_function_name (str, optional): Name of the modifier function applied to the data before calculating traces. This is used to differentiate between traces calculated on raw and modified data. Defaults to an empty string.</span>
<span class="sd">            data_batch_size (int, optional): Size of data batches for processing. Defaults to 1000.</span>
<span class="sd">            cluster_batch_size (int, optional): Size of cluster batches for processing. Defaults to 30.</span>
<span class="sd">            verbose (bool, optional): Whether to print progress messages. Defaults to True.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Predicted cluster labels for each data point.</span>
<span class="sd">            np.ndarray: Maximum log-likelihood values for each data point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">datatype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">for</span> <span class="n">trace_statistic</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}{</span><span class="n">trace_statistic</span><span class="si">}</span><span class="s1">_traces&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster traces with statistic &#39;</span><span class="si">{</span><span class="n">trace_statistic</span><span class="si">}</span><span class="s2">&#39; and modifier function &#39;</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s2">&#39; not found. Please run &#39;save_cluster_trace&#39; or &#39;save_modified_cluster_trace&#39; first.&quot;</span><span class="p">)</span>
        <span class="n">bin_means</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">mean_traces&#39;</span><span class="p">)</span>
        <span class="n">bin_stds</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">std_traces&#39;</span><span class="p">)</span>
        <span class="n">max_logl</span><span class="p">,</span> <span class="n">predicted_cluster</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">data_batch_size</span><span class="p">):</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">jmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">j</span><span class="o">+</span><span class="n">data_batch_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
            <span class="n">data_batch</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">jmax</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_indices</span><span class="p">),</span> <span class="n">cluster_batch_size</span><span class="p">):</span>
                <span class="n">imax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="n">cluster_batch_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_indices</span><span class="p">)))</span>
                <span class="n">bin_means_batch</span><span class="p">,</span> <span class="n">bin_stds_batch</span> <span class="o">=</span> <span class="n">bin_means</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">imax</span><span class="p">],</span> <span class="n">bin_stds</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">imax</span><span class="p">]</span>
                <span class="n">logl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">statistical_models</span><span class="o">.</span><span class="n">logl_uncorrelated_normal</span><span class="p">(</span><span class="n">data_batch</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">datatype</span><span class="p">),</span> <span class="n">bin_means_batch</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">datatype</span><span class="p">),</span> <span class="n">bin_stds_batch</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">datatype</span><span class="p">)))</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">predicted_cluster</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_indices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span>
            <span class="n">max_logl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

        <span class="n">predicted_cluster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">predicted_cluster</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">max_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">max_logl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> 
        <span class="n">predicted_cluster</span><span class="p">[</span><span class="n">max_logl</span> <span class="o">&lt;</span> <span class="n">min_logl</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Mark as noise if log-likelihood is below threshold</span>
        <span class="n">predicted_cluster</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">max_logl</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">_median_uncorrelated_normal_likelihood&#39;</span><span class="p">)[</span><span class="n">predicted_cluster</span><span class="p">]</span> <span class="o">*</span> <span class="n">noise_alpha</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Mark as noise if likelihood is below median likelihood * noise_alpha</span>
        <span class="k">return</span> <span class="n">predicted_cluster</span><span class="p">,</span> <span class="n">max_logl</span></div>

    
<div class="viewcode-block" id="UMAPClassifier.prepare_ml_correlated_normal_prediction">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.prepare_ml_correlated_normal_prediction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prepare_ml_correlated_normal_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare for maximum likelihood prediction assuming correlated normal distributions by calculating and saving the Cholesky factors of each cluster.</span>
<span class="sd">        And also ensures that the cluster mean traces are calculated and saved.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): The input data to be classified.</span>
<span class="sd">            clusters (np.ndarray): Array of cluster indices for each data point.</span>
<span class="sd">            modifier_function_name (str, optional): Name of the modifier function applied to the data before calculating traces. This is used to differentiate between traces calculated on raw and modified data. Defaults to an empty string.</span>
<span class="sd">            verbose (bool, optional): Whether to print progress messages. Defaults to True.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">datatype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_cluster_trace</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">trace_statistic</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="n">modifier_function_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_cluster_cholesky_factors</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="n">modifier_function_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating median correlated normal likelihoods for each cluster.&quot;</span><span class="p">)</span> 
        <span class="n">median_logls</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">bin_means</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">mean_traces&#39;</span><span class="p">)</span>
        <span class="n">W_matrices</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">W_matrices_traces&#39;</span><span class="p">)</span>
        <span class="n">log_dets</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">log_dets_traces&#39;</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">cluster_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_indices</span><span class="p">:</span>  
            <span class="n">cluster_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">clusters</span> <span class="o">==</span> <span class="n">cluster_idx</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">median_logls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">statistical_models</span><span class="o">.</span><span class="n">logl_normal</span><span class="p">(</span><span class="n">cluster_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">datatype</span><span class="p">),</span> 
                                                                         <span class="n">bin_means</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">:</span><span class="n">cluster_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">datatype</span><span class="p">),</span> 
                                                                         <span class="n">W_matrices</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">:</span><span class="n">cluster_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">datatype</span><span class="p">),</span> 
                                                                         <span class="n">log_dets</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">:</span><span class="n">cluster_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">datatype</span><span class="p">))))</span>
        <span class="n">median_logls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">median_logls</span><span class="p">)</span>  <span class="c1"># Normalize likelihood by number of features</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">_median_correlated_normal_likelihood&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">median_logls</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">None</span>  </div>

    
<div class="viewcode-block" id="UMAPClassifier.ml_correlated_normal_prediction">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.ml_correlated_normal_prediction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ml_correlated_normal_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">min_logl</span><span class="o">=-</span><span class="mi">100</span><span class="p">,</span> <span class="n">noise_alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                                            <span class="n">data_batch_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">cluster_batch_size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict cluster labels based on maximum likelihood estimation assuming correlated normal distributions.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): The input data to be classified.</span>
<span class="sd">            min_logl (float, optional): Minimum log-likelihood threshold to consider a point as belonging to a cluster. Points with a log-likelihood below min_logl are labeled as noise (-1). Defaults to -100.</span>
<span class="sd">            noise_alpha (float, optional): Multiplier for the median likelihood to determine noise threshold. Points with a likelihood below median_likelihood * noise_alpha are labeled as noise (-1). Defaults to 0.</span>
<span class="sd">            modifier_function_name (str, optional): Name of the modifier function applied to the data before calculating traces. This is used to differentiate between traces calculated on raw and modified data. Defaults to an empty string.</span>
<span class="sd">            data_batch_size (int, optional): Size of data batches for processing. Defaults to 1000.</span>
<span class="sd">            cluster_batch_size (int, optional): Size of cluster batches for processing. Defaults to 30.</span>
<span class="sd">            verbose (bool, optional): Whether to print progress messages. Defaults to True.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Predicted cluster labels for each data point.</span>
<span class="sd">            np.ndarray: Maximum log-likelihood values for each data point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make sure the cluster properties are available</span>
        <span class="n">datatype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">for</span> <span class="n">trace_statistic</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;W_matrices&quot;</span><span class="p">,</span> <span class="s2">&quot;log_dets&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}{</span><span class="n">trace_statistic</span><span class="si">}</span><span class="s1">_traces&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster traces with statistic &#39;</span><span class="si">{</span><span class="n">trace_statistic</span><span class="si">}</span><span class="s2">&#39; and modifier function &#39;</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s2">&#39; not found. Please run &#39;save_cluster_trace&#39; or &#39;save_cluster_cholesky_factors&#39; first.&quot;</span><span class="p">)</span>

        <span class="n">bin_means</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">mean_traces&#39;</span><span class="p">)</span>
        <span class="n">W_matrices</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">W_matrices_traces&#39;</span><span class="p">)</span>
        <span class="n">log_dets</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">log_dets_traces&#39;</span><span class="p">)</span>
        <span class="n">max_logl</span><span class="p">,</span> <span class="n">predicted_cluster</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">data_batch_size</span><span class="p">):</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">jmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">j</span><span class="o">+</span><span class="n">data_batch_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
            <span class="n">data_batch</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">jmax</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_indices</span><span class="p">),</span> <span class="n">cluster_batch_size</span><span class="p">):</span>
                <span class="n">imax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="n">cluster_batch_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_indices</span><span class="p">)))</span>
                <span class="n">bin_means_batch</span><span class="p">,</span> <span class="n">W_matrices_batch</span><span class="p">,</span> <span class="n">log_dets_batch</span> <span class="o">=</span> <span class="n">bin_means</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">imax</span><span class="p">],</span> <span class="n">W_matrices</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">imax</span><span class="p">],</span> <span class="n">log_dets</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">imax</span><span class="p">]</span>
                <span class="n">logl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">statistical_models</span><span class="o">.</span><span class="n">logl_normal</span><span class="p">(</span><span class="n">data_batch</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">datatype</span><span class="p">),</span> <span class="n">bin_means_batch</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">datatype</span><span class="p">),</span> <span class="n">W_matrices_batch</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">datatype</span><span class="p">),</span> <span class="n">log_dets_batch</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">datatype</span><span class="p">)))</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">predicted_cluster</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_indices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span>
            <span class="n">max_logl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            
        <span class="n">predicted_cluster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">predicted_cluster</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">max_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">max_logl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">predicted_cluster</span><span class="p">[</span><span class="n">max_logl</span> <span class="o">&lt;</span> <span class="n">min_logl</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Mark as noise if log-likelihood is below threshold</span>
        <span class="n">predicted_cluster</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">max_logl</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">_median_correlated_normal_likelihood&#39;</span><span class="p">)[</span><span class="n">predicted_cluster</span><span class="p">]</span> <span class="o">*</span> <span class="n">noise_alpha</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Mark as noise if likelihood is below median likelihood * noise_alpha</span>
        <span class="k">return</span> <span class="n">predicted_cluster</span><span class="p">,</span> <span class="n">max_logl</span></div>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_dbscan_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">data_batch_size</span><span class="o">=</span><span class="mi">20000</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Predict clusters for new data points based on trained DBSCAN model.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            
            <span class="c1"># For very large datasets, process in batches</span>
            <span class="n">nr_samples</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">nr_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>
            
            <span class="c1"># Build nearest neighbors model on DBSCAN components for fast lookup</span>
            <span class="n">nbrs</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">components_</span><span class="p">)</span>
            
            <span class="c1"># Process in batches to avoid memory issues</span>
            <span class="k">for</span> <span class="n">start_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nr_samples</span><span class="p">,</span> <span class="n">data_batch_size</span><span class="p">):</span>
                <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start_idx</span> <span class="o">+</span> <span class="n">data_batch_size</span><span class="p">,</span> <span class="n">nr_samples</span><span class="p">)</span>
                <span class="n">batch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">])</span>
                
                <span class="c1"># Find distance to closest component for each point in batch</span>
                <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>
                
                <span class="c1"># Get the corresponding cluster labels for points within eps</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">model</span><span class="o">.</span><span class="n">eps</span>
                <span class="n">y_new</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">labels_</span><span class="p">[</span>
                    <span class="n">model</span><span class="o">.</span><span class="n">core_sample_indices_</span><span class="p">[</span><span class="n">indices</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">mask</span><span class="p">]]]</span>
            <span class="k">return</span> <span class="n">y_new</span>
    
<div class="viewcode-block" id="UMAPClassifier.umap_transform_prediction">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.umap_transform_prediction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">umap_transform_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">db_eps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_batch_size</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform data using the trained UMAP model and predict clusters using the trained DBSCAN model.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): The input data to be transformed and classified.</span>
<span class="sd">            db_eps (float, optional): Epsilon parameter for DBSCAN. If None, uses the value from the trained DBSCAN model. Defaults to None.</span>
<span class="sd">            data_batch_size (int, optional): Size of data batches for processing. Defaults to 20000.</span>
<span class="sd">            verbose (bool, optional): Whether to print progress messages. Defaults to True.</span>
<span class="sd">        </span>
<span class="sd">        Returns:        </span>
<span class="sd">            np.ndarray: Predicted cluster labels for each data point.</span>
<span class="sd">            np.ndarray: UMAP embeddings for each data point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;umap_model&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;UMAP model not found. Please run &#39;train_embed&#39; first.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;db_model&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DBSCAN model not found. Please run &#39;classify&#39; first.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Transforming data with UMAP model and predicting clusters with DBSCAN (eps=</span><span class="si">{</span><span class="n">db_eps</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">embedding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">n_batches</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="n">data_batch_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">data_batch_size</span>
        <span class="k">for</span> <span class="n">batch_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_batches</span><span class="p">):</span>
            <span class="n">start_idx</span> <span class="o">=</span> <span class="n">batch_idx</span> <span class="o">*</span> <span class="n">data_batch_size</span>
            <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">batch_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">data_batch_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing batch </span><span class="si">{</span><span class="n">start_idx</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">start_idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data_batch_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">batch</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span>
            <span class="n">embedding</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">umap_model</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating DBSCAN model&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">db_eps</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)):</span>
            <span class="n">dbscan_model</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_model</span><span class="p">)</span>
            <span class="n">dbscan_model</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">db_eps</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dbscan_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_model</span>
        <span class="n">predictions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dbscan_predict</span><span class="p">(</span><span class="n">dbscan_model</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">embedding</span><span class="p">),</span> <span class="n">data_batch_size</span><span class="o">=</span><span class="n">data_batch_size</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">predictions</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span></div>

    
    <span class="c1">### Visualization methods</span>
<div class="viewcode-block" id="UMAPClassifier.plot_spectra">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.plot_spectra">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_spectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the spectra of the cluster traces.</span>
<span class="sd">        Args:</span>
<span class="sd">            k (int): The index of the cluster to plot.</span>
<span class="sd">            modifier_function_name (str, optional): Name of the modifier function applied to the data before plotting the traces. This is used to differentiate between traces plotted and the raw data. Defaults to an empty string.</span>
<span class="sd">            sigma (float, optional): Number of standard deviations to plot around the mean trace. If None, standard deviation is not plotted. Defaults to 2.</span>
<span class="sd">            q (float, optional): Quantile value to plot if quantile traces are available. Must be between 0 and 1. If None, quantile traces are not plotted. Defaults to None.</span>
<span class="sd">            **kwargs: Additional keyword arguments to pass to the plotting function. These can include:</span>

<span class="sd">                -** plot_type (list, str): Type of input data to plot. Options are &#39;fft&#39;, &#39;time&#39;, &#39;phase&#39; or &#39;default&#39; which are all provided input data types.</span>
<span class="sd">                -** save_fig (str): Path to save the figure. If None, the figure is not saved. Defaults to None.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            fig, axes: Matplotlib figure and axes objects if save_fig is None, otherwise True after saving the figure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sigma</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">trace_statistic</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}{</span><span class="n">trace_statistic</span><span class="si">}</span><span class="s1">_traces&#39;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster traces with statistic &#39;</span><span class="si">{</span><span class="n">trace_statistic</span><span class="si">}</span><span class="s2">&#39; and modifier function &#39;</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s2">&#39; not found. Please run &#39;save_cluster_trace&#39; or &#39;save_cluster_cholesky_factors&#39; first.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">q</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">trace_statistic</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;quantile&quot;</span><span class="p">,</span><span class="s2">&quot;median&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}{</span><span class="n">trace_statistic</span><span class="si">}</span><span class="s1">_traces&#39;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster traces with statistic &#39;</span><span class="si">{</span><span class="n">trace_statistic</span><span class="si">}</span><span class="s2">&#39; and modifier function &#39;</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s2">&#39; not found. Please run &#39;save_cluster_trace&#39; or &#39;save_cluster_cholesky_factors&#39; first.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">quantile_traces&#39;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster traces with quantile &#39;</span><span class="si">{</span><span class="n">q</span><span class="si">}</span><span class="s2">&#39; and modifier function &#39;</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s2">&#39; not found. Please run &#39;save_cluster_trace&#39; or &#39;save_cluster_cholesky_factors&#39; first.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="mi">1</span><span class="o">-</span><span class="n">q</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s1">quantile_traces&#39;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster traces with quantile &#39;</span><span class="si">{</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="si">}</span><span class="s2">&#39; and modifier function &#39;</span><span class="si">{</span><span class="n">modifier_function_name</span><span class="si">}</span><span class="s2">&#39; not found. Please run &#39;save_cluster_trace&#39; or &#39;save_cluster_cholesky_factors&#39; first.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">visualization</span><span class="o">.</span><span class="n">plot_spectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">modifier_function_name</span><span class="o">=</span><span class="n">modifier_function_name</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="UMAPClassifier.plot_cluster_samples">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.plot_cluster_samples">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_cluster_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prepared_data</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">cluster_idx</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot samples from a specific cluster.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            prepared_data (np.ndarray): The prepared data used for clustering.</span>
<span class="sd">            clusters (np.ndarray): Array of cluster indices for each data point.</span>
<span class="sd">            cluster_idx (int): The index of the cluster to plot samples from.</span>
<span class="sd">            **kwargs: Additional keyword arguments to pass to the plotting function.</span>
<span class="sd">                These can include:</span>
<span class="sd">                </span>
<span class="sd">                -** n_samples (int): Number of samples to plot. Defaults to 100.</span>
<span class="sd">                -** random_state (int): Random seed for reproducibility. Defaults to None.</span>
<span class="sd">                -** plot_type (list, str): Type of input data to plot. Options are &#39;fft&#39;, &#39;time&#39;, &#39;phase&#39; or &#39;default&#39; which are all provided input data types.</span>
<span class="sd">                -** save_fig (str): Path to save the figure. If None, the figure is not saved. Defaults to None.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            fig, axes: Matplotlib figure and axes objects if save_fig is None, otherwise True after saving the figure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">visualization</span><span class="o">.</span><span class="n">plot_cluster_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prepared_data</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">cluster_idx</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="UMAPClassifier.plot_index">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.plot_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prepared_data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot data samples based on a provided index array.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            prepared_data (np.ndarray): The prepared data used for clustering.</span>
<span class="sd">            index (np.ndarray): Array of indices to plot. Should be the same length as prepared_data.</span>
<span class="sd">            **kwargs: Additional keyword arguments to pass to the plotting function.</span>
<span class="sd">                These can include:</span>
<span class="sd">                </span>
<span class="sd">                -** plot_type (list, str): Type of input data to plot. Options are &#39;fft&#39;, &#39;time&#39;, &#39;phase&#39; or &#39;default&#39; which are all provided input data types.</span>
<span class="sd">                -** save_fig (str): Path to save the figure. If None, the figure is not saved. Defaults to None.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            fig, axes: Matplotlib figure and axes objects if save_fig is None, otherwise True&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">visualization</span><span class="o">.</span><span class="n">plot_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prepared_data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="UMAPClassifier.plot_embedding">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.plot_embedding">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_embedding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the UMAP embedding with optional labels.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            embedding (np.ndarray): The UMAP embedding to plot.</span>
<span class="sd">            labels (np.ndarray, optional): Array of labels for coloring the embedding. If None, no labels are used. Defaults to None.</span>
<span class="sd">            **kwargs: Additional keyword arguments to pass to the plotting function.</span>
<span class="sd">                These can include:</span>
<span class="sd">                -** save_fig (str): Path to save the figure. If None, the figure is not saved. Defaults to None.</span>
<span class="sd">                -** label_name (str): Name of the labels for the colorbar. Defaults to &quot;Cluster&quot;.</span>
<span class="sd">                -** label_type (str): Type of labels. Options are &#39;categorical&#39; or &#39;continuous&#39;. Defaults to &#39;categorical&#39;.</span>
<span class="sd">                -** alpha (float): Alpha value for point transparency. Defaults to 0.01.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            fig, axes: Matplotlib figure and axes objects if save_fig is None, otherwise True after saving the figure.</span>
<span class="sd">                &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">visualization</span><span class="o">.</span><span class="n">plot_embdding</span><span class="p">(</span><span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="UMAPClassifier.plot_overview_bokeh">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.plot_overview_bokeh">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_overview_bokeh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">color_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;UMAP Overview&quot;</span><span class="p">,</span> <span class="n">save_fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">hover_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an interactive Bokeh plot of the UMAP embedding.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            embedding (np.ndarray): The UMAP embedding to plot.</span>
<span class="sd">            color_key (str or None): Attribute name in hover_kwargs to use for coloring the points. If None, no coloring is applied.</span>
<span class="sd">            title (str, optional): Title of the plot. Defaults to &quot;UMAP Overview&quot;.</span>
<span class="sd">            save_fig (str, optional): Path to save the Bokeh plot as an HTML file</span>
<span class="sd">            **hover_kwargs: Additional keyword arguments to pass to the plotting function essentially arrays with the same length as embedding, which contain information about each point in the embedding, which is displayed when hovering over the points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">visualization</span><span class="o">.</span><span class="n">plot_overview_bokeh</span><span class="p">(</span><span class="n">embedding</span><span class="p">,</span> <span class="n">color_key</span><span class="o">=</span><span class="n">color_key</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">save_fig</span><span class="o">=</span><span class="n">save_fig</span><span class="p">,</span> <span class="o">**</span><span class="n">hover_kwargs</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="UMAPClassifier.load_umap_data_batchwise_from_dir">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.load_umap_data_batchwise_from_dir">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_umap_data_batchwise_from_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dir_path</span><span class="p">,</span> <span class="n">data_batch_loader_kwargs</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">data_batch_loader</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">max_umap_events</span> <span class="o">=</span> <span class="mf">1e5</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n_selected_per_batch</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">summary_batch_size</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">local_embedding</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">return_raw</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">umap_kwargs</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">clustering_kwargs</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">clustering_mode</span> <span class="o">=</span> <span class="s2">&quot;dbscan&quot;</span><span class="p">,</span>
                            <span class="n">file_extension</span> <span class="o">=</span> <span class="s2">&quot;.pkl&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Load data from a directory in batches, perform UMAP embedding and clustering on each batch, and select a high-entropy subset of the data.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            dir_path (str): Path to the directory containing data files.</span>
<span class="sd">            data_batch_loader (callable): A function that takes a batch index and a file path, and returns a tuple (data_batch, properties_batch, change_file). Here data_batch is a numpy array of shape (n_samples_in_batch, n_features), properties_batch is an optional numpy array of shape (n_samples_in_batch, n_properties), and change_file is a boolean indicating whether to move to the next file. Default is None, which uses a default loader that expects .pkl files containing pandas DataFrames.</span>
<span class="sd">            data_batch_loader_kwargs (dict): Additional keyword arguments to pass to the data_batch_loader function. Defaults to {}.</span>
<span class="sd">            max_umap_events (int): Maximum number of events to select for UMAP embedding. Defaults to 1e5.</span>
<span class="sd">            batch_size (int): Number of events to process in each batch. If None defaults to max_umap_events. Defaults to None.</span>
<span class="sd">            n_selected_per_batch (int): Number of events to select from each batch. If None defaults to max_umap_events/10. Defaults to None.</span>
<span class="sd">            summary_batch_size (int): Number of events to accumulate before performing a final selection. If None defaults to batch_size. Defaults to None.</span>
<span class="sd">            local_embedding (bool): Whether to use parameters for UMAP and DBSCAN supporting local embedding and clustering for each batch. Default is True.</span>
<span class="sd">            return_raw (bool): Whether to return the raw data along with the processed data. Default is False.</span>
<span class="sd">            umap_kwargs (dict): Additional keyword arguments to pass to the UMAP embedding function. Defaults to {}.</span>
<span class="sd">            clustering_kwargs (dict): Additional keyword arguments to pass to the clustering function. Defaults to {}.</span>
<span class="sd">            clustering_mode (str): Clustering algorithm to use, either &quot;dbscan&quot; or &quot;hdbscan&quot;. Default is &quot;dbscan&quot;.</span>
<span class="sd">            file_extension (str): File extension of the data files to load. Default is &quot;.pkl&quot;.</span>
<span class="sd">            verbose (bool): Whether to print progress messages. Default is True.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            selected_data (np.ndarray): A numpy array of shape (n_selected_events, n_features) containing the selected events after UMAP embedding and clustering.</span>
<span class="sd">            selected_raw_data (np.ndarray): A numpy array of shape (n_selected_events, n_raw_features) containing the raw data of the selected events. Returned only if return_raw is True.</span>
<span class="sd">            selected_properties (np.ndarray): A numpy array of shape (n_selected_events, n_properties) containing the properties of the selected events. Returned only if properties are provided by the data_batch_loader.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">umap_data_loader</span><span class="o">.</span><span class="n">load_umap_data_batchwise_from_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dir_path</span><span class="p">,</span> <span class="n">data_batch_loader_kwargs</span> <span class="o">=</span> <span class="n">data_batch_loader_kwargs</span><span class="p">,</span> <span class="n">data_batch_loader</span> <span class="o">=</span> <span class="n">data_batch_loader</span><span class="p">,</span>
                            <span class="n">max_umap_events</span> <span class="o">=</span> <span class="n">max_umap_events</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">n_selected_per_batch</span> <span class="o">=</span> <span class="n">n_selected_per_batch</span><span class="p">,</span> <span class="n">summary_batch_size</span> <span class="o">=</span> <span class="n">summary_batch_size</span><span class="p">,</span>
                            <span class="n">local_embedding</span> <span class="o">=</span> <span class="n">local_embedding</span><span class="p">,</span> <span class="n">return_raw</span> <span class="o">=</span> <span class="n">return_raw</span><span class="p">,</span>
                            <span class="n">umap_kwargs</span> <span class="o">=</span> <span class="n">umap_kwargs</span><span class="p">,</span> <span class="n">clustering_kwargs</span> <span class="o">=</span> <span class="n">clustering_kwargs</span><span class="p">,</span> <span class="n">clustering_mode</span> <span class="o">=</span> <span class="n">clustering_mode</span><span class="p">,</span>
                            <span class="n">file_extension</span> <span class="o">=</span> <span class="n">file_extension</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>


<div class="viewcode-block" id="UMAPClassifier.load_umap_data_from_dir">
<a class="viewcode-back" href="../../api/rm_classifier.umap_classifier.html#rm_classifier.umap_classifier.UMAPClassifier.load_umap_data_from_dir">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_umap_data_from_dir</span><span class="p">(</span><span class="n">umap_classifier</span><span class="p">,</span> <span class="n">dir_path</span><span class="p">,</span> <span class="n">data_loader</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">data_loader_kwargs</span> <span class="o">=</span> <span class="p">{},</span> 
                            <span class="n">max_umap_events</span> <span class="o">=</span> <span class="mf">1e5</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n_selected_per_batch</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">summary_batch_size</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">local_embedding</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">return_raw</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">umap_kwargs</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">clustering_kwargs</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">clustering_mode</span> <span class="o">=</span> <span class="s2">&quot;dbscan&quot;</span><span class="p">,</span>
                            <span class="n">file_extension</span> <span class="o">=</span> <span class="s2">&quot;.pkl&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Load data from a directory, seperate into batches, perform UMAP embedding and clustering on each batch, and select a high-entropy subset of the data.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            dir_path (str): Path to the directory containing data files. </span>
<span class="sd">            data_loader (callable): A function that takes a file path and returns a tuple (data, properties). Here data is a numpy array of shape (n_samples, n_features) and properties is an optional numpy array of shape (n_samples, n_properties). Default is None, which uses a default loader that expects .pkl files containing pandas DataFrames.</span>
<span class="sd">            data_loader_kwargs (dict): Additional keyword arguments to pass to the data_loader function. Defaults to {}.</span>
<span class="sd">            max_umap_events (int): Maximum number of events to select for UMAP embedding. Default is 1e5.</span>
<span class="sd">            batch_size (int): Number of events to process in each batch. If None defaults to max_umap_events. Defaults to None.</span>
<span class="sd">            n_selected_per_batch (int): Number of events to select from each batch. If None defaults to max_umap_events/10. Defaults to None.</span>
<span class="sd">            summary_batch_size (int): Number of events to accumulate before performing a final selection. If None defaults to batch_size. Defaults to None.</span>
<span class="sd">            local_embedding (bool): Whether to use parameters for UMAP and DBSCAN supporting local embedding and clustering for each batch. Default is True.</span>
<span class="sd">            return_raw (bool): Whether to return the raw data along with the processed data. Default is False.</span>
<span class="sd">            umap_kwargs (dict): Additional keyword arguments to pass to the UMAP embedding function. Defaults to {}.</span>
<span class="sd">            clustering_kwargs (dict): Additional keyword arguments to pass to the clustering function. Defaults to {}.</span>
<span class="sd">            clustering_mode (str): Clustering algorithm to use, either &quot;dbscan&quot; or &quot;hdbscan&quot;. Default is &quot;dbscan&quot;.</span>
<span class="sd">            file_extension (str): File extension of the data files to load. Default is &quot;.pkl&quot;.</span>
<span class="sd">            verbose (bool): Whether to print progress messages. Default is True.     </span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            selected_data (np.ndarray): A numpy array of shape (n_selected_events, n_features) containing the selected events after UMAP embedding and clustering.</span>
<span class="sd">            selected_raw_data (np.ndarray): A numpy array of shape (n_selected_events, n_raw_features) containing the raw data of the selected events. Returned only if return_raw is True.</span>
<span class="sd">            selected_properties (np.ndarray): A numpy array of shape (n_selected_events, n_properties) containing the properties of the selected events. Returned only if properties are provided by the data_loader.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">umap_data_loader</span><span class="o">.</span><span class="n">load_umap_data_from_dir</span><span class="p">(</span><span class="n">umap_classifier</span><span class="p">,</span> <span class="n">dir_path</span><span class="p">,</span> <span class="n">data_loader</span> <span class="o">=</span> <span class="n">data_loader</span><span class="p">,</span> <span class="n">data_loader_kwargs</span> <span class="o">=</span> <span class="n">data_loader_kwargs</span><span class="p">,</span>
                            <span class="n">max_umap_events</span> <span class="o">=</span> <span class="n">max_umap_events</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">n_selected_per_batch</span> <span class="o">=</span> <span class="n">n_selected_per_batch</span><span class="p">,</span> <span class="n">summary_batch_size</span> <span class="o">=</span> <span class="n">summary_batch_size</span><span class="p">,</span>
                            <span class="n">local_embedding</span> <span class="o">=</span> <span class="n">local_embedding</span><span class="p">,</span> <span class="n">return_raw</span> <span class="o">=</span> <span class="n">return_raw</span><span class="p">,</span>
                            <span class="n">umap_kwargs</span> <span class="o">=</span> <span class="n">umap_kwargs</span><span class="p">,</span> <span class="n">clustering_kwargs</span> <span class="o">=</span> <span class="n">clustering_kwargs</span><span class="p">,</span> <span class="n">clustering_mode</span> <span class="o">=</span> <span class="n">clustering_mode</span><span class="p">,</span>
                            <span class="n">file_extension</span> <span class="o">=</span> <span class="n">file_extension</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Johann Luca Kastner.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>